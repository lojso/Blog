# Рекурсия
Рекурсия это когда функция или метод ссылается на саму себя. В рекурсивной функции крайне желательно наличие условие выхода, иначе будет получена ошибка переполнения стека или памяти, так как ресурсы не бесконечные.

Одним из самых распространенных способов знакомства с рекурсией является вычисление чисел Фибоначчи. Числа Фибоначчи это элементы числовой последовательности в которой первые два числа равны 0 и 1, а каждое последующее число равно сумме двух предыдущих чисел. Кроме этого числа Фибоначчи могут проиллюстрировать другую еще одну концепцию (тоже связанную с рекурсией) - алгоритмы "разделяй и властвуй". Это такие алгоритмы, которые делят задачу на более мелкие задачи, вплоть до тривиальных случаев и итоговое решение выдают как комбинацию решений этих более мелких задач.

Псевдокод для Фибоначчи:
```
Fibonacci(n):
    if(n <= 1)
        return n

    n2 = Fibonacci(n - 2)
    n1 = Fibonacci(n - 1)
    return n2 + n1
```
Алгоритм разбивает задачу вычисления числа на 2 подзадачи: вычисление 2 предыдущих чисел и получение корректного ответа сложением полученных решений для более простых подзадач. Задача разбивается вплоть до тривиальных случаев, которыми являются решение для чисел 1 и 0. Они же и являются условием выхода из рекурсии.
## Конкретный пример
Посмотрим как будет разворачиваться описанный выше алгоритм для числа 5:
```
Fibonacci(5)
->
Fibonacci(3) + Fibonacci(4)
->
(Fibonacci(1) + Fibonacci(2)) + (Fibonacci(3) + Fibonacci(2))
->
(1 + (Fibonacci(0) + Fibonacci(1))) + ((Fibonacci(1) + Fibonacci(2)) + (Fibonacci(0) + Fibonacci(1)))
->
(1 + (0 + 1)) + ((1 + Fibonacci(2)) + (0 + 1))
->
(1 + (0 + 1)) + ((1 + (Fibonacci(0) + Fibonacci(1))) + (0 + 1))
->
(1 + 1) + ((1 + (0 + 1)) + 1)
->
2 + ((1 + 1) + 1)
->
2 + (2 + 1)
->
2 + 3
->
5
```
Мы разбиваем задачу на подзадачу пока не получим тривиальный вариант задачи: 0 и 1. После этого мы комбинируем полученные ответы, чтобы получить ответ на исходную задачу.